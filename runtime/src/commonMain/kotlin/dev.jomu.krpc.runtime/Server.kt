package dev.jomu.krpc.runtime

import dev.jomu.krpc.Response.Error
import dev.jomu.krpc.ErrorCode
import dev.jomu.krpc.Metadata
import dev.jomu.krpc.Response
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.json.Json

/**
 * A function that calls the implementation of the kRPC service with the parameters and metadata from the request
 *
 * @param Service
 * The interface of the kRPC service
 *
 * @param Req
 * The request type
 *
 * @param Resp
 * The response type for success cases
 *
 * @param Err
 * The [error details][Error.details] for the failure case
 */
typealias MethodHandler<Service, Req, Resp, Err> = suspend (service: Service, request: Req, metadata: Metadata) -> Response<Resp, Err>

/**
 * The runtime description of a single method of a kRPC service
 *
 * Instances of this class are usually automatically generated by the kRPC client.
 *
 * Contains the information required to register a method for its path and then handle requests to that path.
 *
 * @param info
 * Metadata of the method
 *
 * @param handler
 * A function that calls the implementation of the kRPC service with the parameters and metadata from the request
 *
 * @param Service
 * The interface of the kRPC service
 *
 * @param Req
 * The request type
 *
 * @param Resp
 * The response type for success cases
 *
 * @param Err
 * The [error details][Error.details] for the failure case
 */
class MethodDescriptor<Service, Req, Resp, Err>(
    val info: MethodInfo<Req, Resp, Err>,
    val handler: MethodHandler<Service, Req, Resp, Err>,
)

/**
 * The runtime description of a kRPC service
 *
 * Instances of this class are usually automatically generated by the kRPC client.
 *
 * @param name
 * The name of the kRPC service, usually the fully qualified name of the interface
 *
 * @param methods
 * All methods of the kRPC service
 */
class ServiceDescriptor<T>(internal val name: String, internal val methods: List<MethodDescriptor<T, *, *, *>>)

/**
 * Handles requests conforming to the kRPC protocol
 */
interface KrpcServer {
    /**
     * Computes the response for a request to a given path
     *
     * Based on the [path] this function will find the corresponding [method][MethodDescriptor] and then call the implementation
     * of the kRPC service with the parameters from the request. If no method was registered for the [path] an [Error] with
     * [ErrorCode.UNIMPLEMENTED] will be returned.
     *
     * @param path
     * The path of the HTTP request
     *
     * @param incomingMessage
     * The request that was received
     *
     * @return
     * An encodable [response][OutgoingMessage]
     */
    suspend fun handleRequest(path: String, incomingMessage: IncomingMessage): OutgoingMessage<*>
}

internal class RegisteredService<T>(val descriptor: ServiceDescriptor<T>, val implementation: T)

/**
 * Class used to configure a [KrpcServer]
 */
class KrpcServerBuilder {
    internal val interceptors: MutableList<UnaryServerInterceptor> = mutableListOf()
    internal val services: MutableList<RegisteredService<*>> = mutableListOf()

    /**
     * Adds an interceptor that will be used for all registered [services][ServiceDescriptor] of this [KrpcServer]
     */
    fun addInterceptor(interceptor: UnaryServerInterceptor) {
        interceptors.add(interceptor)
    }

    /**
     * Registers a kRPC service
     *
     * @param descriptor
     * [ServiceDescriptor] of the kRPC service
     *
     * @param implementation
     * The implementation of the kRPC service
     */
    fun <T> addService(descriptor: ServiceDescriptor<T>, implementation: T) {
        services.add(RegisteredService(descriptor, implementation))
    }
}

/**
 * Creates a configured [KrpcServer]
 *
 * @param block
 * Configures a [KrpcServerBuilder] from which a [KrpcServer] is built
 */
fun buildKrpcServer(block: KrpcServerBuilder.() -> Unit): KrpcServer {
    val builder = KrpcServerBuilder()
    builder.block()
    return RealKrpcServer(
        builder.services,
        Json { ignoreUnknownKeys = true },
        builder.interceptors
    )
}


@OptIn(ExperimentalStdlibApi::class)
private class RealKrpcServer(
    services: List<RegisteredService<*>>,
    private val json: Json,
    interceptors: List<UnaryServerInterceptor> = emptyList(),
) : KrpcServer {
    private val interceptor = if (interceptors.isEmpty()) null else ChainUnaryServerInterceptor(interceptors)
    private val handlers = services.map { rs -> rs.toHandlerMap() }.fold(emptyMap<String, ImplementationWithMethod<*>>()) { a, b -> a + b }

    override suspend fun handleRequest(path: String, incomingMessage: IncomingMessage): OutgoingMessage<*> {
        val path = path.trimStart('/')
        if (path.isEmpty()) {
            return createGenericError(ErrorCode.INVALID_ARGUMENT, "Path may not be empty")
        }
        val handler =
            handlers[path] ?: return createGenericError(ErrorCode.UNIMPLEMENTED, "$path not implemented")
        return try {
            handler.handle(incomingMessage)
        } catch (e: Exception) {
            createGenericError(ErrorCode.INTERNAL, e.message ?: "<internal error>")
        }
    }

    private suspend fun <T> ImplementationWithMethod<T>.handle(incomingMessage: IncomingMessage): OutgoingMessage<*> {
        return method.handle(implementation, incomingMessage)
    }

    private suspend fun <Service, Req, Resp, Err> MethodDescriptor<Service, Req, Resp, Err>.handle(
        implementation: Service,
        incomingMessage: IncomingMessage
    ): OutgoingMessage<Response<Resp, Err>> {
        val request = incomingMessage.read(json, info.requestSerializer)
        val metadata = metadataFromHttpHeaders(incomingMessage.headers)

        val response = interceptor?.intercept(info, request, metadata) { request, metadata ->
            handler(implementation, request, metadata)
        } ?: handler(implementation, request, metadata)
        return OutgoingMessage(response.metadata.toHttpHeaders(), response, info.responseSerializer, json)
    }

    fun createGenericError(code: ErrorCode, message: String): OutgoingMessage<*> {
        return OutgoingMessage(emptyMap(), Error(code, message), ResponseSerializer(Unit.serializer(), Unit.serializer()), json)
    }
}

private class ImplementationWithMethod<T>(val implementation: T, val method: MethodDescriptor<T, *, *, *>)

private fun <T> RegisteredService<T>.toHandlerMap(): Map<String, ImplementationWithMethod<T>> {
    return descriptor.methods.associateBy {
        it.info.path
    }.mapValues { ImplementationWithMethod(implementation, it.value) }
}